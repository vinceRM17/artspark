---
phase: 03-prompt-generation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/constants/twists.ts
  - lib/schemas/prompts.ts
  - lib/services/prompts.ts
autonomous: true

must_haves:
  truths:
    - "Prompt generation combines user's preferred medium, subject, and optional color rule into a readable prompt sentence"
    - "Excluded subjects never appear in generated prompts"
    - "Same subject does not repeat within 14-day window (graceful fallback for small pools)"
    - "Approximately 50% of prompts include a creative twist element"
    - "Only one daily prompt per user per date (date_key deduplication)"
    - "Manual prompts are allowed unlimited per day (source='manual')"
  artifacts:
    - path: "lib/constants/twists.ts"
      provides: "CREATIVE_TWISTS array of 20 twist strings"
      exports: ["CREATIVE_TWISTS"]
    - path: "lib/schemas/prompts.ts"
      provides: "Prompt type definition and Zod schema"
      exports: ["Prompt", "promptSchema"]
    - path: "lib/services/prompts.ts"
      provides: "Core prompt generation and retrieval functions"
      exports: ["getTodayPrompt", "createManualPrompt"]
  key_links:
    - from: "lib/services/prompts.ts"
      to: "lib/services/preferences.ts"
      via: "getPreferences import for user preference data"
      pattern: "import.*getPreferences.*from.*preferences"
    - from: "lib/services/prompts.ts"
      to: "lib/constants/preferences.ts"
      via: "MEDIUM_OPTIONS, SUBJECT_OPTIONS, COLOR_PALETTE_OPTIONS for label lookup"
      pattern: "import.*OPTIONS.*from.*constants/preferences"
    - from: "lib/services/prompts.ts"
      to: "lib/constants/twists.ts"
      via: "CREATIVE_TWISTS array for random twist selection"
      pattern: "import.*CREATIVE_TWISTS.*from.*constants/twists"
    - from: "lib/services/prompts.ts"
      to: "supabase.from('prompts')"
      via: "Supabase client for prompt CRUD operations"
      pattern: "supabase.*from.*prompts"
---

<objective>
Build the complete prompt generation service layer: type definitions, creative twist constants, and the core algorithm that generates personalized daily prompts from user preferences with subject rotation, exclusion filtering, and date-based deduplication.

Purpose: This is the engine of the app -- the logic that turns user preferences into daily creative prompts. Without this, the home screen has nothing to display. The service handles all the tricky parts: never showing excluded subjects, avoiding recent repeats within a 14-day window, and ensuring the same daily prompt persists across multiple app opens.

Output: Three files that provide the complete prompt generation backend. The prompts table SQL migration is documented in comments (same pattern as user_preferences in Phase 2).
</objective>

<execution_context>
@/Users/vincecain/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vincecain/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-prompt-generation/03-RESEARCH.md

# Existing files this plan integrates with
@lib/supabase.ts
@lib/services/preferences.ts
@lib/constants/preferences.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Prompt type, schema, and creative twists constants</name>
  <files>lib/constants/twists.ts, lib/schemas/prompts.ts</files>
  <action>
Create two files:

**lib/constants/twists.ts:**
Export a `CREATIVE_TWISTS` string array with exactly 20 creative twist strings. These are optional additions to prompts (~50% of prompts get one). Use the list from the research:
- "Use only 3 colors"
- "Work from memory, not reference"
- "Create in under 30 minutes"
- "Focus on texture over detail"
- "Use negative space intentionally"
- "Emphasize light and shadow"
- "Incorporate a geometric element"
- "Try a perspective you've never used"
- "Work larger than usual"
- "Work smaller than usual"
- "Use an unusual tool or technique"
- "Create a series of 3 quick studies"
- "Focus on movement and energy"
- "Simplify to essential shapes only"
- "Add an unexpected element"
- "Use complementary colors only"
- "Create a mood, not a scene"
- "Work in monochrome"
- "Emphasize pattern and repetition"
- "Break a rule you usually follow"

**lib/schemas/prompts.ts:**
Define the `Prompt` TypeScript type matching the database schema:
```typescript
export type Prompt = {
  id: string;
  user_id: string;
  date_key: string;        // YYYY-MM-DD format, UTC
  source: 'daily' | 'manual';
  medium: string;          // ID from MEDIUM_OPTIONS
  subject: string;         // ID from SUBJECT_OPTIONS
  color_rule: string | null;  // ID from COLOR_PALETTE_OPTIONS or null
  twist: string | null;       // Full twist text or null
  prompt_text: string;        // Full assembled prompt sentence
  created_at: string;
};
```

Also export a Zod schema (`promptSchema`) for runtime validation of prompt data coming back from Supabase. Use `z.object()` with appropriate types for each field. Mark `color_rule` and `twist` as `z.string().nullable()`.

Include a JSDoc comment at the top of the file documenting the SQL migration needed to create the `prompts` table in Supabase (same documentation pattern used in `lib/services/preferences.ts`). The SQL is:

```sql
CREATE TABLE prompts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  date_key TEXT NOT NULL,
  source TEXT NOT NULL DEFAULT 'daily',
  medium TEXT NOT NULL,
  subject TEXT NOT NULL,
  color_rule TEXT,
  twist TEXT,
  prompt_text TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  CONSTRAINT unique_daily_prompt UNIQUE (user_id, date_key, source),
  CONSTRAINT valid_source CHECK (source IN ('daily', 'manual'))
);

CREATE INDEX idx_prompts_user_date ON prompts(user_id, date_key DESC);
CREATE INDEX idx_prompts_user_subject_recent ON prompts(user_id, subject, created_at DESC);

ALTER TABLE prompts ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can read own prompts"
  ON prompts FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own prompts"
  ON prompts FOR INSERT WITH CHECK (auth.uid() = user_id);
```

NOTE: The unique constraint on (user_id, date_key, source) means only ONE daily prompt per user per date, but MULTIPLE manual prompts are allowed because each manual INSERT creates a new row (the constraint only blocks duplicates with the exact same user_id + date_key + source combo, and for manual prompts the timestamp makes them unique -- wait, no. The constraint would block multiple manual prompts on the same day since source='manual' is the same. IMPORTANT FIX: For manual prompts, we need to use INSERT (not upsert), and the unique constraint should only apply to daily prompts. The simplest fix: make the constraint partial -- OR change approach to use a unique index instead:

```sql
CREATE UNIQUE INDEX unique_daily_prompt ON prompts(user_id, date_key) WHERE source = 'daily';
```

This partial unique index enforces one daily prompt per user per date while allowing unlimited manual prompts. Use this instead of the CONSTRAINT approach. Update the SQL in the JSDoc accordingly.
  </action>
  <verify>
Run `npx tsc --noEmit` from project root. Both files should compile without errors. Verify:
- `lib/constants/twists.ts` exports CREATIVE_TWISTS with exactly 20 items
- `lib/schemas/prompts.ts` exports Prompt type and promptSchema
  </verify>
  <done>
CREATIVE_TWISTS array has 20 string entries. Prompt type has all 10 fields matching the database schema. promptSchema validates all fields with correct types. SQL migration documented in JSDoc comment with partial unique index for daily-only deduplication.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build complete prompt generation service</name>
  <files>lib/services/prompts.ts</files>
  <action>
Create `lib/services/prompts.ts` with the following exports and internal functions:

**Internal helpers (not exported):**

1. `getTodayDateKey(): string` -- Returns `new Date().toISOString().split('T')[0]` for UTC YYYY-MM-DD format. Used for date_key in all prompt operations.

2. `randomItem<T>(array: T[]): T` -- Returns a random element from a non-empty array using `Math.floor(Math.random() * array.length)`.

3. `getEligibleSubjects(userId, userSubjects, exclusions, repeatWindowDays = 14): Promise<string[]>` -- Core rotation algorithm:
   - Calculate cutoff date (today minus repeatWindowDays)
   - Query supabase `prompts` table: SELECT subject WHERE user_id = userId AND created_at >= cutoffDate, ordered by created_at DESC
   - Build a Set of recent subjects from query results
   - Filter userSubjects: remove any subject that is in exclusions OR in recentSubjects
   - Graceful fallback: if filtered list is empty (all subjects used recently), fall back to userSubjects minus exclusions only (allowing repeats but still respecting exclusions)
   - Return eligible subjects array

4. `assemblePromptText(medium, subject, colorRule, twist): string` -- Builds human-readable prompt:
   - Look up display labels from MEDIUM_OPTIONS, SUBJECT_OPTIONS, COLOR_PALETTE_OPTIONS using `.find(m => m.id === medium)?.label || medium`
   - Base: `"Create a ${mediumLabel.toLowerCase()} piece featuring ${subjectLabel.toLowerCase()}"`
   - If colorRule: append ` with ${colorLabel.toLowerCase()} colors`
   - If twist: append `. ${twist}`
   - Return assembled string

5. `generatePrompt(userId, preferences, source): Promise<PromptData>` -- Orchestrates generation:
   - Pick random medium from `preferences.art_mediums`
   - Get eligible subjects via `getEligibleSubjects(userId, preferences.subjects, preferences.exclusions || [], 14)`
   - Pick random subject from eligible list
   - Color rule: if `preferences.color_palettes?.length > 0` AND `Math.random() < 0.4`, pick random color palette; else null
   - Twist: if `Math.random() < 0.5`, pick random from CREATIVE_TWISTS; else null
   - Assemble prompt text
   - Return `{ source, medium, subject, color_rule, twist, prompt_text }`

**Exported functions:**

6. `getTodayPrompt(userId: string): Promise<Prompt>` -- Idempotent daily prompt:
   - Get today's date_key
   - Query supabase for existing prompt: `.from('prompts').select('*').eq('user_id', userId).eq('date_key', today).eq('source', 'daily').single()`
   - If exists and no error, return it (same prompt all day)
   - If not found (PGRST116 or null data), generate new prompt:
     - Fetch preferences via `getPreferences(userId)` from preferences service
     - If preferences null, throw Error("User preferences not found. Please complete onboarding.")
     - Call `generatePrompt(userId, preferences, 'daily')`
     - Upsert to supabase with `onConflict: 'user_id,date_key,source'` (handles race condition). Note: since we use partial unique index, the onConflict for upsert needs to reference the constraint name or the columns. Use `.upsert({...}, { onConflict: 'user_id,date_key,source' })` -- Supabase will match against the partial unique index.
     - Return the inserted/returned prompt
   - Handle __DEV__ mode: if no session/userId available, return a mock prompt with hardcoded values so the home screen works during development without Supabase

7. `createManualPrompt(userId: string): Promise<Prompt>` -- On-demand extra prompt:
   - Fetch preferences via `getPreferences(userId)`
   - If preferences null, throw Error
   - Call `generatePrompt(userId, preferences, 'manual')`
   - Use `.insert()` (NOT upsert) since manual prompts don't have uniqueness constraint
   - Get today's date_key for the date_key field
   - Return the inserted prompt

**Imports needed:**
- `{ supabase }` from `@/lib/supabase`
- `{ getPreferences }` from `./preferences` (note: same directory)
- `{ UserPreferences }` from `./preferences`
- `{ MEDIUM_OPTIONS, SUBJECT_OPTIONS, COLOR_PALETTE_OPTIONS }` from `@/lib/constants/preferences`
- `{ CREATIVE_TWISTS }` from `@/lib/constants/twists`
- `{ Prompt }` from `@/lib/schemas/prompts`

Re-export `Prompt` type from this file for convenience: `export type { Prompt } from '@/lib/schemas/prompts';`

**IMPORTANT: Do NOT use the CONSTRAINT approach for uniqueness.** The SQL uses a partial unique index (`WHERE source = 'daily'`). For the upsert in getTodayPrompt, since Supabase JS client upsert onConflict works with column names, use `onConflict: 'user_id,date_key,source'`. The partial unique index will only trigger for daily prompts. For manual prompts, always use `.insert()` which bypasses the uniqueness concern entirely.

**Error handling pattern:** Follow the same pattern as preferences.ts -- throw errors from Supabase, handle PGRST116 (no rows) gracefully.
  </action>
  <verify>
Run `npx tsc --noEmit` from project root. File should compile without type errors. Verify:
- `getTodayPrompt` and `createManualPrompt` are exported
- File imports from supabase, preferences service, and constants
- `getEligibleSubjects` queries prompts table with date range filter
- `assemblePromptText` looks up labels from OPTIONS constants
- `generatePrompt` uses Math.random() for twist (~50%) and color (~40%) probability
  </verify>
  <done>
Complete prompt service exists at lib/services/prompts.ts with: getTodayPrompt (idempotent daily), createManualPrompt (unlimited on-demand), getEligibleSubjects (14-day rotation with graceful fallback), assemblePromptText (label-based text assembly), generatePrompt (orchestrator). All functions handle edge cases (empty preferences, subject pool exhaustion, race conditions via upsert). SQL migration documented. TypeScript compiles cleanly.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no new errors
2. Three new files exist: lib/constants/twists.ts, lib/schemas/prompts.ts, lib/services/prompts.ts
3. CREATIVE_TWISTS has 20 entries
4. Prompt type matches database schema (10 fields)
5. getTodayPrompt and createManualPrompt are exported from prompts service
6. Service imports getPreferences from preferences service (real integration)
7. SQL migration documented in comments with partial unique index
</verification>

<success_criteria>
- Prompt service compiles and exports getTodayPrompt + createManualPrompt
- getEligibleSubjects filters exclusions AND recent subjects (14-day window)
- Graceful fallback when all subjects are recently used (allow repeats, still respect exclusions)
- assemblePromptText produces readable sentence from preference IDs
- ~50% twist probability, ~40% color rule probability (when user has color prefs)
- Daily prompt uses upsert for idempotent retrieval, manual prompt uses insert
- SQL migration documented for prompts table with partial unique index
</success_criteria>

<output>
After completion, create `.planning/phases/03-prompt-generation/03-01-SUMMARY.md`
</output>
