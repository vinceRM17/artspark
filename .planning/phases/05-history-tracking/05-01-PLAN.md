---
phase: 05-history-tracking
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/schemas/prompts.ts
  - lib/services/prompts.ts
  - lib/services/responses.ts
  - lib/hooks/usePromptHistory.ts
autonomous: true

must_haves:
  truths:
    - "Prompt history can be fetched with completion status in a single query"
    - "History data paginates with offset-based loading"
    - "History hook provides loading, error, refresh, and loadMore states"
  artifacts:
    - path: "lib/schemas/prompts.ts"
      provides: "PromptWithStatus type extending Prompt with response_count and is_completed"
      contains: "PromptWithStatus"
    - path: "lib/services/prompts.ts"
      provides: "getPromptHistory and getPromptById functions"
      exports: ["getPromptHistory", "getPromptById"]
    - path: "lib/hooks/usePromptHistory.ts"
      provides: "Paginated history hook with caching"
      exports: ["usePromptHistory"]
  key_links:
    - from: "lib/hooks/usePromptHistory.ts"
      to: "lib/services/prompts.ts"
      via: "getPromptHistory call in fetchHistory"
      pattern: "getPromptHistory"
    - from: "lib/services/prompts.ts"
      to: "supabase"
      via: "JOIN query with responses(count)"
      pattern: "responses.*count"
---

<objective>
Build the data layer for prompt history: extend the Prompt schema with completion status, add paginated history query and single-prompt detail query to the prompts service, and create the usePromptHistory hook with pagination, AsyncStorage caching, and refresh support.

Purpose: Provide all data-fetching infrastructure so the UI layer (Plan 02) can render history list and detail views without any service/hook work.
Output: Extended prompts schema and service, new usePromptHistory hook ready for UI consumption.
</objective>

<execution_context>
@/Users/vincecain/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vincecain/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-history-tracking/05-RESEARCH.md

@lib/schemas/prompts.ts
@lib/schemas/response.ts
@lib/services/prompts.ts
@lib/services/responses.ts
@lib/hooks/useDailyPrompt.ts
@lib/supabase.ts
@components/auth/SessionProvider.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend prompts schema and services with history queries</name>
  <files>
    lib/schemas/prompts.ts
    lib/services/prompts.ts
    lib/services/responses.ts
  </files>
  <action>
**lib/schemas/prompts.ts** — Add PromptWithStatus type after the existing Prompt type:

```typescript
export type PromptWithStatus = Prompt & {
  response_count: number;
  is_completed: boolean;
};
```

Do NOT add a Zod schema for PromptWithStatus — it is computed client-side from the JOIN query result. Keep the existing Prompt type and promptSchema unchanged.

**lib/services/prompts.ts** — Add two new exported functions AFTER the existing exports (getTodayPrompt, createManualPrompt). Do NOT modify existing functions.

1. `getPromptHistory(userId: string, limit: number = 20, offset: number = 0)` — Returns `{ prompts: PromptWithStatus[], total: number }`.
   - Uses Supabase `.select('*, responses:responses(count)', { count: 'exact' })` for a single JOIN query
   - Filters `.eq('user_id', userId)`
   - Orders `.order('created_at', { ascending: false })` — newest first
   - Paginates `.range(offset, offset + limit - 1)`
   - Transforms the result: maps each row to set `response_count = p.responses?.[0]?.count || 0` and `is_completed = response_count > 0`, then deletes the raw `responses` property
   - Import PromptWithStatus from `@/lib/schemas/prompts`

2. `getPromptById(userId: string, promptId: string)` — Returns `Promise<PromptWithStatus | null>`.
   - Uses Supabase `.select('*, responses:responses(count)')` with `.eq('user_id', userId).eq('id', promptId).single()`
   - Same response_count/is_completed transform as above
   - Returns null if PGRST116 error (not found), throws on other errors

**lib/services/responses.ts** — Add one new exported function AFTER existing exports:

`getResponsesForPromptWithImages(userId: string, promptId: string)` — Returns `Promise<Response[]>`.
   - Same query as existing `getResponsesForPrompt` but also generates signed URLs for images
   - For each response, map over `image_urls` and call `supabase.storage.from('responses').createSignedUrl(url, 3600)` to get 1-hour signed URLs
   - Return responses with signed URLs replacing the storage paths
   - If in `__DEV__` mode and no userId, return mock data: one response with placeholder image URLs and sample notes/tags

This function is needed because the detail view must display actual images, and Supabase Storage is private (requires signed URLs).
  </action>
  <verify>
  - TypeScript compilation: `npx tsc --noEmit` passes (or at minimum the modified files have no type errors)
  - PromptWithStatus type is exported from lib/schemas/prompts.ts
  - getPromptHistory and getPromptById are exported from lib/services/prompts.ts
  - getResponsesForPromptWithImages is exported from lib/services/responses.ts
  - No existing exports are modified or broken
  </verify>
  <done>
  - PromptWithStatus type extends Prompt with response_count (number) and is_completed (boolean)
  - getPromptHistory fetches paginated prompts with JOIN response count in a single query
  - getPromptById fetches single prompt with response count
  - getResponsesForPromptWithImages returns responses with signed image URLs
  - All functions follow existing service patterns (async, throw on error, userId filtering)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create usePromptHistory hook with pagination and caching</name>
  <files>
    lib/hooks/usePromptHistory.ts
  </files>
  <action>
Create `lib/hooks/usePromptHistory.ts` following the exact pattern from `useDailyPrompt.ts` (useState/useEffect, useSession for userId, __DEV__ fallback).

**Hook signature:** `usePromptHistory()` returns:
```typescript
{
  prompts: PromptWithStatus[];
  loading: boolean;
  error: string | null;
  hasMore: boolean;
  loadMore: () => void;
  refresh: () => Promise<void>;
}
```

**Implementation details:**

- Constants: `CACHE_KEY = '@artspark:prompt-history'`, `CACHE_TTL = 5 * 60 * 1000` (5 minutes), `PAGE_SIZE = 20`
- State: prompts (PromptWithStatus[]), loading (boolean), error (string | null), offset (number), hasMore (boolean)
- Use `useSession()` for userId, import from `@/components/auth/SessionProvider`

**fetchHistory(fromOffset: number, append: boolean):**
- If no userId and `__DEV__`: set mock data (3 sample PromptWithStatus items with varying is_completed), setLoading(false), return
- If no userId (production): setLoading(false), return
- On first load (fromOffset === 0, !append): check AsyncStorage cache. If valid (within CACHE_TTL), set prompts from cache and set loading to false. Continue to fetch fresh data in background regardless.
- Call `getPromptHistory(userId, PAGE_SIZE, fromOffset)`
- If append: spread new prompts onto existing array
- If not append: replace prompts array and update AsyncStorage cache (store `{ data, timestamp }`)
- Update hasMore: `fromOffset + newPrompts.length < total`
- Update offset: `fromOffset + newPrompts.length`
- Catch errors to setError

**useEffect:** Call `fetchHistory(0, false)` on mount when userId changes.

**loadMore:** If not loading and hasMore, call `fetchHistory(offset, true)`. Wrap in useCallback with deps [loading, hasMore, offset, fetchHistory].

**refresh:** Remove CACHE_KEY from AsyncStorage, reset offset to 0, call `fetchHistory(0, false)`. Wrap in useCallback.

**Cache invalidation helper:** Export a standalone function `invalidateHistoryCache()` that calls `AsyncStorage.removeItem(CACHE_KEY)`. This will be called from the response creation flow in Plan 02 to ensure the history reflects new responses.

Follow the same coding style as useDailyPrompt.ts: explicit return type, descriptive JSDoc comment at top, imports at top of file.
  </action>
  <verify>
  - File exists at lib/hooks/usePromptHistory.ts
  - TypeScript compilation passes for this file
  - Hook exports usePromptHistory and invalidateHistoryCache
  - Hook uses useSession, AsyncStorage, and getPromptHistory from the correct imports
  - __DEV__ mock data path exists for development without auth
  </verify>
  <done>
  - usePromptHistory hook provides prompts, loading, error, hasMore, loadMore, refresh
  - Hook fetches first page on mount, supports infinite scroll via loadMore
  - AsyncStorage cache with 5-min TTL reduces redundant API calls
  - invalidateHistoryCache exported for cross-feature cache clearing
  - __DEV__ fallback provides 3 mock prompts for development iteration
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with no errors in modified/created files
- PromptWithStatus type properly extends Prompt
- getPromptHistory returns paginated results with completion status
- usePromptHistory hook compiles and exports expected interface
- No regressions to existing exports (getTodayPrompt, createManualPrompt, createResponse, getResponsesForPrompt)
</verification>

<success_criteria>
- All 4 files (schemas/prompts.ts, services/prompts.ts, services/responses.ts, hooks/usePromptHistory.ts) exist and compile
- History service returns prompts with is_completed boolean derived from response count JOIN
- Hook supports pagination (loadMore), pull-to-refresh (refresh), and caching (AsyncStorage)
- Cache invalidation function is exported for use by response creation flow
</success_criteria>

<output>
After completion, create `.planning/phases/05-history-tracking/05-01-SUMMARY.md`
</output>
