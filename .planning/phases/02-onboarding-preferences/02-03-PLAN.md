---
phase: 02-onboarding-preferences
plan: 03
type: execute
wave: 3
depends_on: ["02-01", "02-02"]
files_modified:
  - app/onboarding/step-5.tsx
  - lib/notifications.ts
  - app/index.tsx
  - app/(auth)/_layout.tsx
autonomous: false
user_setup:
  - service: supabase
    why: "User preferences table must exist in Supabase"
    env_vars: []
    dashboard_config:
      - task: "Run the CREATE TABLE user_preferences SQL migration in Supabase SQL Editor"
        location: "Supabase Dashboard -> SQL Editor -> New Query"

must_haves:
  truths:
    - "User can set preferred daily notification time during onboarding (ONBD-05)"
    - "User sees clear value explanation before notification permission request"
    - "User preferences are saved to Supabase and persist across sessions"
    - "User can skip notification permission and still complete onboarding"
    - "After onboarding completion, user lands in the main app and cannot navigate back to onboarding"
    - "New users who haven't completed onboarding are redirected to onboarding flow"
    - "Returning users who completed onboarding go directly to main app"
  artifacts:
    - path: "app/onboarding/step-5.tsx"
      provides: "Notification time selection + onboarding completion"
      min_lines: 60
    - path: "lib/notifications.ts"
      provides: "Notification scheduling and permission utilities"
      exports: ["scheduleDailyPrompt", "requestNotificationPermission"]
    - path: "app/index.tsx"
      provides: "Root routing with onboarding redirect logic"
    - path: "app/(auth)/_layout.tsx"
      provides: "Auth layout unchanged or with onboarding awareness"
  key_links:
    - from: "app/onboarding/step-5.tsx"
      to: "lib/services/preferences.ts"
      via: "calls savePreferences + markOnboardingComplete"
      pattern: "savePreferences|markOnboardingComplete"
    - from: "app/onboarding/step-5.tsx"
      to: "lib/notifications.ts"
      via: "calls scheduleDailyPrompt"
      pattern: "scheduleDailyPrompt"
    - from: "app/onboarding/step-5.tsx"
      to: "expo-router"
      via: "router.replace('/(auth)') after completion"
      pattern: "router\\.replace.*auth"
    - from: "app/index.tsx"
      to: "lib/hooks/useOnboardingStatus.ts"
      via: "checks onboarding status for routing"
      pattern: "useOnboardingStatus"
---

<objective>
Build onboarding step 5 (notification time + completion), notification scheduling, and routing integration so new users get redirected to onboarding and returning users skip it.

Purpose: This is the capstone plan that ties everything together. Step 5 collects notification preferences, saves ALL collected preferences to Supabase, marks onboarding complete, and replaces the navigation stack so users land in the main app. The routing changes in index.tsx ensure new users are funneled into onboarding while returning users go straight to the app.

Output: Complete, working onboarding flow from start to finish with Supabase persistence and proper routing.
</objective>

<execution_context>
@/Users/vincecain/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vincecain/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-onboarding-preferences/02-RESEARCH.md
@.planning/phases/02-onboarding-preferences/02-01-SUMMARY.md
@.planning/phases/02-onboarding-preferences/02-02-SUMMARY.md
@app/index.tsx
@app/(auth)/_layout.tsx
@components/auth/SessionProvider.tsx
@lib/supabase.ts
@lib/services/preferences.ts
@lib/hooks/useOnboardingStatus.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create notification utilities and step 5 screen</name>
  <files>
    lib/notifications.ts
    app/onboarding/step-5.tsx
  </files>
  <action>
**Install dependencies first:**
```bash
npx expo install expo-notifications @react-native-community/datetimepicker
```

**1. Create `lib/notifications.ts`:**

```typescript
import * as Notifications from 'expo-notifications';
```

Functions:
- `requestNotificationPermission()`: Calls `Notifications.requestPermissionsAsync()`. Returns `{ granted: boolean, status: string }`. Does NOT throw on denial -- just returns granted: false.
- `scheduleDailyPrompt(hour: number, minute: number)`: First cancels all existing scheduled notifications via `Notifications.cancelAllScheduledNotificationsAsync()`. Then schedules a new daily notification with `type: Notifications.SchedulableTriggerInputTypes.DAILY`, `hour`, `minute`. Content: title "Your daily art prompt is ready", body "Open ArtSpark for today's creative inspiration", sound true. Returns the notification identifier string.
- `cancelAllNotifications()`: Cancels all scheduled notifications. For use when user disables notifications.

Also configure notification handler at module level:
```typescript
Notifications.setNotificationHandler({
  handleNotification: async () => ({
    shouldShowAlert: true,
    shouldPlaySound: true,
    shouldSetBadge: false,
  }),
});
```

**2. Create `app/onboarding/step-5.tsx` (Notification Time + Completion):**

This step has TWO phases: (a) notification value explanation + permission, (b) time selection.

Screen title: "When should we inspire you?"
Subtitle: "Get a daily art prompt at your favorite creative time."

**Phase A - Permission explanation (show first if permission not yet granted):**
Before showing the time picker, show a value explanation screen:
- Heading: "Daily creative nudge"
- Body: "We'll send you one gentle reminder each day at the time you choose. No spam, no noise -- just your daily spark of inspiration."
- "Enable notifications" button (large, sage green, primary)
- "Maybe later" text button below (skips permission, proceeds to time picker anyway)

When user taps "Enable notifications": call requestNotificationPermission(). Regardless of result, proceed to Phase B.
When user taps "Maybe later": proceed to Phase B (skip permission request).

**Phase B - Time picker:**
Show a time picker using `@react-native-community/datetimepicker`:
- Default time: 9:00 AM
- On iOS: use display="spinner", always visible
- On Android: show a button "Tap to change time" that opens the picker; display the currently selected time on the button
- Below the picker, show a "Complete Setup" button (large, sage green, filled)

**On "Complete Setup" press:**
1. Read ALL accumulated preferences from AsyncStorage key `@artspark:onboarding-progress`
2. Get session from useSession()
3. Format notification time as "HH:MM:00" string (pad hours and minutes with leading zeros)
4. Call `savePreferences(session.user.id, { art_mediums: progress.mediums, color_palettes: progress.colorPalettes || [], subjects: progress.subjects, exclusions: progress.exclusions || [], notification_time: formattedTime, notification_enabled: permissionWasGranted, onboarding_completed: true })`
5. If notification permission was granted, call `scheduleDailyPrompt(hour, minute)`
6. Clear AsyncStorage onboarding progress key
7. Call `router.replace('/(auth)')` to navigate to main app and clear onboarding from history

Show a loading indicator on the "Complete Setup" button while saving (disable it, show ActivityIndicator).

Handle errors: If savePreferences fails, show an Alert.alert with the error message and do NOT navigate away. Let user retry.

Step is 5 of 5.
  </action>
  <verify>
Run `npx tsc --noEmit`. Both files compile. Verify:
- `lib/notifications.ts` exports requestNotificationPermission, scheduleDailyPrompt, cancelAllNotifications
- `app/onboarding/step-5.tsx` imports from notifications.ts and preferences service
- Step 5 has value explanation before permission request
- Step 5 saves all preferences to Supabase on completion
- Step 5 uses router.replace('/(auth)') after save
  </verify>
  <done>
lib/notifications.ts provides permission request, daily scheduling, and cancellation. Step 5 shows value explanation before requesting notification permission, lets user set time via native picker, saves all accumulated preferences to Supabase, schedules notification if permitted, and replaces navigation to main app.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate onboarding routing into app navigation</name>
  <files>
    app/index.tsx
    app/(auth)/_layout.tsx
  </files>
  <action>
**1. Update `app/index.tsx`:**

Current behavior: Redirects to /(auth) if session exists or __DEV__, else to /sign-in.
New behavior: After auth, check onboarding status before redirecting.

Import `useOnboardingStatus` from `@/lib/hooks/useOnboardingStatus`.

Logic flow:
```
if (__DEV__):
  check onboardingComplete from useOnboardingStatus
  if loading: show spinner
  if onboardingComplete === true: redirect to /(auth)
  if onboardingComplete === false: redirect to /onboarding/step-1

if (isLoading): show spinner

if (!session): redirect to /sign-in

// Has session, check onboarding
check onboardingComplete from useOnboardingStatus
if onboardingComplete loading: show spinner
if onboardingComplete === true: redirect to /(auth)
if onboardingComplete === false: redirect to /onboarding/step-1
```

IMPORTANT for __DEV__: The useOnboardingStatus hook already has dev bypass logic (checks AsyncStorage key). So in dev mode without the key set, it will query Supabase. If Supabase isn't configured in dev, this might fail. Handle this gracefully: if useOnboardingStatus encounters an error in __DEV__ mode, default to redirecting to /(auth) (don't block dev access). Add a try/catch or error state to useOnboardingStatus if not already present.

The loading spinner should be the same style as existing (View with white bg, ActivityIndicator, centered).

**2. Update `app/(auth)/_layout.tsx`:**

Add a guard at the top of the component that checks onboarding status. If user somehow reaches (auth) without completing onboarding (e.g., deep link), redirect them to onboarding.

Import `useOnboardingStatus` from `@/lib/hooks/useOnboardingStatus`.

Add after the existing isLoading check:
```typescript
const { onboardingComplete, loading: onboardingLoading } = useOnboardingStatus();

// After existing session/loading checks...
if (onboardingLoading) {
  return loading spinner;
}

if (!onboardingComplete && !__DEV__) {
  return <Redirect href="/onboarding/step-1" />;
}
```

Wait -- this creates a double-check. The index.tsx already redirects. The (auth)/_layout.tsx guard is a safety net for edge cases (direct navigation, deep links). In __DEV__ mode, skip the onboarding check in _layout.tsx to avoid blocking local development (the useOnboardingStatus dev bypass already handles this via AsyncStorage key).

Keep the existing session check and Stack navigation intact. Just add the onboarding guard as an additional layer.
  </action>
  <verify>
Run `npx tsc --noEmit`. Both files compile. Test the routing logic mentally:
1. New user: sign-in -> index.tsx checks session (yes) + onboarding (no) -> redirects to /onboarding/step-1
2. Returning user: index.tsx checks session (yes) + onboarding (yes) -> redirects to /(auth)
3. Unauthenticated: index.tsx checks session (no) -> redirects to /sign-in
4. Dev mode: index.tsx checks __DEV__ -> checks onboarding status (with AsyncStorage bypass) -> appropriate redirect
  </verify>
  <done>
app/index.tsx routes users to onboarding if not completed, to main app if completed, to sign-in if unauthenticated. app/(auth)/_layout.tsx has safety guard preventing access without completed onboarding. Dev bypass maintained via useOnboardingStatus hook.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify complete onboarding flow</name>
  <files>
    app/onboarding/step-1.tsx
    app/onboarding/step-5.tsx
  </files>
  <action>
Human verifies the complete 5-step onboarding flow built across plans 02-01, 02-02, and 02-03. This checkpoint confirms end-to-end functionality: medium selection (required), color palettes (optional/skippable), subjects (required), exclusions (optional/skippable, filters out already-selected subjects), notification time with permission explanation. All preferences saved to Supabase. Routing redirects new users to onboarding, returning users to main app.

**Pre-requisite:** You must have run the SQL migration to create the `user_preferences` table in your Supabase project. The SQL is in the comments at the top of `lib/services/preferences.ts`. Go to Supabase Dashboard -> SQL Editor -> New Query, paste the SQL, and run it.

**Test the flow:**
1. Start the app with `npx expo start`
2. If in dev mode and you want to test onboarding routing, clear the dev bypass: run the app and check if it redirects to onboarding. If it goes straight to home, you may need to remove the `@artspark:dev-skip-onboarding` key from AsyncStorage (or just test in production mode).
3. Walk through all 5 steps:
   - Step 1: Select at least 1 medium. Try tapping "Next" with none selected -- should show error.
   - Step 2: Optionally select colors OR tap "Skip this step". Both should work.
   - Step 3: Select at least 1 subject. Verify error on empty submission.
   - Step 4: Verify that subjects you selected in step 3 do NOT appear here. Skip or select exclusions.
   - Step 5: See notification value explanation. Tap "Enable" or "Maybe later". Pick a time. Tap "Complete Setup".
4. After completion, you should land on the main app home screen.
5. Force-close and reopen the app -- you should go directly to home, NOT back to onboarding.
6. Check Supabase Dashboard -> Table Editor -> user_preferences: verify your preferences were saved correctly.

**What to look for:**
- Artistic, warm color palette (cream backgrounds, sage green chips)
- Big, obvious buttons
- Smooth step-to-step navigation
- No way to swipe back during onboarding
- Clean typography and generous spacing

Type "approved" or describe any issues with the flow, styling, or behavior.
  </action>
  <verify>
User confirms the onboarding flow works end-to-end by typing "approved" or describing issues.
  </verify>
  <done>
User has verified: onboarding flow completes successfully, preferences are saved to Supabase, routing works correctly for new and returning users, artistic styling meets expectations.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes
- New user route: sign-in -> onboarding -> main app (no back navigation)
- Returning user route: straight to main app (onboarding skipped)
- All 5 preference categories collected and saved to Supabase
- Notification permission requested contextually with value explanation
- Notification time saved even if permission denied
- router.replace() used after completion (no back to onboarding)
- gestureEnabled: false prevents swipe-back
- __DEV__ bypass works for development
</verification>

<success_criteria>
- Complete onboarding flow works end-to-end (5 steps)
- Preferences persist in Supabase user_preferences table
- New users are redirected to onboarding after auth
- Completed users skip onboarding on subsequent launches
- Notification permission requested after value explanation
- Notification scheduled at user's chosen time (if permitted)
- All styling follows artistic direction (warm, clean, big buttons)
- No regression to existing auth flow
</success_criteria>

<output>
After completion, create `.planning/phases/02-onboarding-preferences/02-03-SUMMARY.md`
</output>
