---
phase: 01-foundation-auth
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - app/sign-in.tsx
  - app/verify-otp.tsx
  - app/(auth)/_layout.tsx
  - app/(auth)/index.tsx
  - app/(auth)/settings.tsx
autonomous: false

must_haves:
  truths:
    - "User can sign up with email and receive OTP code"
    - "User can enter OTP code and successfully authenticate"
    - "User session persists when app is closed and reopened"
    - "User can log out from Settings and session is cleared"
    - "User is redirected to sign-in when accessing protected features while logged out"
  artifacts:
    - path: "app/sign-in.tsx"
      provides: "Email entry screen for OTP request"
      contains: "signIn"
      min_lines: 40
    - path: "app/verify-otp.tsx"
      provides: "OTP code verification screen"
      contains: "verifyOtp"
      min_lines: 40
    - path: "app/(auth)/_layout.tsx"
      provides: "Protected route guard layout"
      contains: "Redirect"
      min_lines: 30
    - path: "app/(auth)/index.tsx"
      provides: "Protected home screen placeholder"
      min_lines: 20
    - path: "app/(auth)/settings.tsx"
      provides: "Settings screen with logout button"
      contains: "signOut"
      min_lines: 30
  key_links:
    - from: "app/sign-in.tsx"
      to: "components/auth/SessionProvider"
      via: "useSession() hook for signIn method"
      pattern: "useSession.*signIn"
    - from: "app/verify-otp.tsx"
      to: "components/auth/SessionProvider"
      via: "useSession() hook for verifyOtp method"
      pattern: "useSession.*verifyOtp"
    - from: "app/(auth)/_layout.tsx"
      to: "components/auth/SessionProvider"
      via: "useSession() hook for session guard"
      pattern: "useSession.*session"
    - from: "app/(auth)/settings.tsx"
      to: "components/auth/SessionProvider"
      via: "useSession() hook for signOut method"
      pattern: "useSession.*signOut"
    - from: "app/verify-otp.tsx"
      to: "app/(auth)/index"
      via: "router.replace() after successful verification"
      pattern: "router\\.replace.*auth"
---

<objective>
Build complete authentication UI flow with OTP-based passwordless sign-in and protected routes.

Purpose: Create all user-facing authentication screens (sign-in, OTP verification) and implement protected route guards that prevent unauthenticated access. This completes Phase 1 by delivering a working auth system users can interact with.

Output:
- Sign-in screen with email input and OTP request
- OTP verification screen with code entry
- Protected route layout with session guard
- Placeholder home screen (protected)
- Settings screen with logout functionality (protected)
- End-to-end authentication flow working
</objective>

<execution_context>
@/Users/vincecain/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vincecain/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-auth/01-RESEARCH.md
@.planning/phases/01-foundation-auth/01-01-SUMMARY.md
@.planning/phases/01-foundation-auth/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Create sign-in screen with OTP request</name>
  <files>
    app/sign-in.tsx
  </files>
  <action>
Create unprotected sign-in screen where users enter email to request OTP code.

Implementation:

```typescript
// app/sign-in.tsx
import { useState } from 'react';
import { View, Text, TextInput, TouchableOpacity, Alert, ActivityIndicator } from 'react-native';
import { useSession } from '@/components/auth/SessionProvider';
import { router, Redirect } from 'expo-router';

export default function SignIn() {
  const [email, setEmail] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const { session, signIn } = useSession();

  // If already logged in, redirect to home
  if (session) {
    return <Redirect href="/(auth)" />;
  }

  const handleSignIn = async () => {
    if (!email.trim()) {
      Alert.alert('Error', 'Please enter your email');
      return;
    }

    // Basic email validation
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      Alert.alert('Error', 'Please enter a valid email address');
      return;
    }

    setIsLoading(true);
    try {
      await signIn(email.toLowerCase().trim());
      Alert.alert(
        'Check your email',
        'We sent you a login code. Enter it on the next screen.',
        [
          {
            text: 'OK',
            onPress: () => router.push({ pathname: '/verify-otp', params: { email: email.toLowerCase().trim() } }),
          },
        ]
      );
    } catch (error: any) {
      Alert.alert('Error', error.message || 'Failed to send login code');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <View className="flex-1 bg-white px-6 justify-center">
      <Text className="text-3xl font-bold mb-2">Welcome to ArtSpark</Text>
      <Text className="text-gray-600 mb-8">
        Sign in to get your daily art inspiration
      </Text>

      <Text className="text-sm font-medium text-gray-700 mb-2">Email</Text>
      <TextInput
        className="border border-gray-300 rounded-lg px-4 py-3 mb-4 text-base"
        placeholder="your@email.com"
        value={email}
        onChangeText={setEmail}
        autoCapitalize="none"
        keyboardType="email-address"
        autoCorrect={false}
        editable={!isLoading}
      />

      <TouchableOpacity
        className="bg-blue-600 rounded-lg py-3 mb-4"
        onPress={handleSignIn}
        disabled={isLoading}
      >
        {isLoading ? (
          <ActivityIndicator color="white" />
        ) : (
          <Text className="text-white text-center font-semibold text-base">
            Send Login Code
          </Text>
        )}
      </TouchableOpacity>

      <Text className="text-xs text-gray-500 text-center">
        We'll send you a one-time code to sign in. No passwords needed.
      </Text>
    </View>
  );
}
```

IMPORTANT:
- Destructure signIn from useSession() at component level (line 11), NOT inside handleSignIn handler
- This avoids React hooks rules violation
- Redirect to /(auth) if already logged in (prevents showing sign-in to authenticated users)
- Use router.push (not replace) to maintain back navigation from OTP screen
- Trim and lowercase email before sending
- Use NativeWind classes for styling (StoryGraph-inspired clean design)
  </action>
  <verify>
1. Run app and navigate to /sign-in
2. Verify email input accepts text and validates format
3. Verify "Send Login Code" button is disabled while loading
4. Enter valid email and tap button
5. Verify alert shows "Check your email" message
6. Verify navigation to /verify-otp screen with email param
7. Check Supabase logs to confirm OTP email was sent
  </verify>
  <done>
Sign-in screen allows user to enter email, validates input, sends OTP request via Supabase, and navigates to verification screen. Already-authenticated users are redirected to home.
  </done>
</task>

<task type="auto">
  <name>Create OTP verification screen</name>
  <files>
    app/verify-otp.tsx
  </files>
  <action>
Create OTP verification screen where users enter the code received via email.

Implementation:

```typescript
// app/verify-otp.tsx
import { useState } from 'react';
import { View, Text, TextInput, TouchableOpacity, Alert, ActivityIndicator } from 'react-native';
import { useSession } from '@/components/auth/SessionProvider';
import { router, useLocalSearchParams } from 'expo-router';

export default function VerifyOtp() {
  const { email } = useLocalSearchParams<{ email: string }>();
  const [otp, setOtp] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const { verifyOtp, signIn } = useSession();

  const handleVerify = async () => {
    if (!otp.trim()) {
      Alert.alert('Error', 'Please enter the code from your email');
      return;
    }

    if (!email) {
      Alert.alert('Error', 'Email address is missing. Please go back and try again.');
      return;
    }

    setIsLoading(true);
    try {
      await verifyOtp(email, otp.trim());
      // On success, onAuthStateChange will update session
      // Protected route guard will automatically redirect to /(auth)
      router.replace('/(auth)');
    } catch (error: any) {
      Alert.alert(
        'Verification Failed',
        error.message || 'Invalid or expired code. Please try again.'
      );
    } finally {
      setIsLoading(false);
    }
  };

  const handleResend = async () => {
    setIsLoading(true);
    try {
      await signIn(email);
      Alert.alert('Code Resent', 'Check your email for a new login code');
    } catch (error: any) {
      Alert.alert('Error', error.message || 'Failed to resend code');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <View className="flex-1 bg-white px-6 justify-center">
      <Text className="text-3xl font-bold mb-2">Check your email</Text>
      <Text className="text-gray-600 mb-8">
        We sent a code to {email}
      </Text>

      <Text className="text-sm font-medium text-gray-700 mb-2">
        Verification Code
      </Text>
      <TextInput
        className="border border-gray-300 rounded-lg px-4 py-3 mb-4 text-base text-center tracking-widest"
        placeholder="000000"
        value={otp}
        onChangeText={setOtp}
        keyboardType="number-pad"
        autoFocus
        maxLength={6}
        editable={!isLoading}
      />

      <TouchableOpacity
        className="bg-blue-600 rounded-lg py-3 mb-4"
        onPress={handleVerify}
        disabled={isLoading}
      >
        {isLoading ? (
          <ActivityIndicator color="white" />
        ) : (
          <Text className="text-white text-center font-semibold text-base">
            Verify Code
          </Text>
        )}
      </TouchableOpacity>

      <TouchableOpacity onPress={handleResend} disabled={isLoading}>
        <Text className="text-blue-600 text-center text-sm">
          Didn't receive a code? Resend
        </Text>
      </TouchableOpacity>

      <TouchableOpacity onPress={() => router.back()} className="mt-4">
        <Text className="text-gray-600 text-center text-sm">
          Back to sign in
        </Text>
      </TouchableOpacity>
    </View>
  );
}
```

IMPORTANT:
- Destructure both verifyOtp AND signIn from useSession() at component level (line 11), NOT inside handleResend handler
- This avoids React hooks rules violation in the handleResend function
- Use router.replace (not push) after verification to prevent back-navigation to OTP screen
- maxLength={6} for OTP input (Supabase default OTP length)
- number-pad keyboard for easier code entry
- Provide resend option in case email doesn't arrive
  </action>
  <verify>
1. Navigate to /verify-otp from sign-in screen
2. Verify email parameter is displayed
3. Enter 6-digit OTP code received via email
4. Tap "Verify Code"
5. On success, verify automatic redirect to /(auth)/index
6. Test "Resend" button - verify new OTP email is sent
7. Test invalid code - verify error alert appears
8. Test "Back to sign in" navigation
  </verify>
  <done>
OTP verification screen successfully validates codes, authenticates users via Supabase, and redirects to protected home screen. Resend functionality works for missed emails.
  </done>
</task>

<task type="auto">
  <name>Implement protected route layout and screens</name>
  <files>
    app/(auth)/_layout.tsx
    app/(auth)/index.tsx
    app/(auth)/settings.tsx
  </files>
  <action>
Create protected route group with session guard and placeholder home/settings screens.

Implementation:

1. Create app/(auth)/_layout.tsx:
```typescript
// app/(auth)/_layout.tsx
import { Redirect, Stack } from 'expo-router';
import { useSession } from '@/components/auth/SessionProvider';
import { View, ActivityIndicator } from 'react-native';

export default function AuthLayout() {
  const { session, isLoading } = useSession();

  // Show loading spinner while checking session
  if (isLoading) {
    return (
      <View className="flex-1 justify-center items-center bg-white">
        <ActivityIndicator size="large" color="#2563eb" />
      </View>
    );
  }

  // Redirect to sign-in if no session
  if (!session) {
    return <Redirect href="/sign-in" />;
  }

  return (
    <Stack>
      <Stack.Screen
        name="index"
        options={{
          title: 'Home',
          headerShown: true,
        }}
      />
      <Stack.Screen
        name="settings"
        options={{
          title: 'Settings',
          headerShown: true,
        }}
      />
    </Stack>
  );
}
```

2. Create app/(auth)/index.tsx:
```typescript
// app/(auth)/index.tsx
import { View, Text, TouchableOpacity } from 'react-native';
import { router } from 'expo-router';
import { useSession } from '@/components/auth/SessionProvider';

export default function Home() {
  const { session } = useSession();

  return (
    <View className="flex-1 bg-white px-6 justify-center">
      <Text className="text-3xl font-bold mb-2">Welcome!</Text>
      <Text className="text-gray-600 mb-8">
        You're signed in as {session?.user?.email}
      </Text>

      <Text className="text-gray-500 mb-4">
        This is a placeholder home screen for Phase 1.
        Daily prompts will appear here in Phase 3.
      </Text>

      <TouchableOpacity
        className="bg-gray-200 rounded-lg py-3"
        onPress={() => router.push('/(auth)/settings')}
      >
        <Text className="text-gray-800 text-center font-semibold">
          Go to Settings
        </Text>
      </TouchableOpacity>
    </View>
  );
}
```

3. Create app/(auth)/settings.tsx:
```typescript
// app/(auth)/settings.tsx
import { View, Text, TouchableOpacity, Alert } from 'react-native';
import { useSession } from '@/components/auth/SessionProvider';
import { router } from 'expo-router';

export default function Settings() {
  const { session, signOut } = useSession();

  const handleLogout = () => {
    Alert.alert(
      'Log Out',
      'Are you sure you want to log out?',
      [
        { text: 'Cancel', style: 'cancel' },
        {
          text: 'Log Out',
          style: 'destructive',
          onPress: async () => {
            try {
              await signOut();
              router.replace('/sign-in');
            } catch (error: any) {
              Alert.alert('Error', error.message || 'Failed to log out');
            }
          },
        },
      ]
    );
  };

  return (
    <View className="flex-1 bg-white px-6 pt-6">
      <View className="mb-8">
        <Text className="text-sm font-medium text-gray-500 mb-1">
          Signed in as
        </Text>
        <Text className="text-base text-gray-900">
          {session?.user?.email}
        </Text>
      </View>

      <TouchableOpacity
        className="bg-red-600 rounded-lg py-3"
        onPress={handleLogout}
      >
        <Text className="text-white text-center font-semibold">
          Log Out
        </Text>
      </TouchableOpacity>

      <Text className="text-xs text-gray-500 mt-4">
        Phase 1: Foundation + Auth complete. Preferences, prompts,
        and other features coming in future phases.
      </Text>
    </View>
  );
}
```

IMPORTANT:
- Protected layout MUST check isLoading before checking session (prevents flash)
- Use router.replace (not push) after logout to clear history
- Show confirmation alert before logout (prevents accidental sign-out)
- Display user email from session.user.email
  </action>
  <verify>
1. While signed out, try to navigate to /(auth)/index - verify redirect to /sign-in
2. Sign in and verify automatic navigation to /(auth)/index
3. Verify home screen displays user email
4. Navigate to settings
5. Tap "Log Out" and confirm
6. Verify redirect to /sign-in and session is cleared
7. Close and reopen app while signed in - verify session persists and user stays on home screen
  </verify>
  <done>
Protected route layout successfully guards against unauthenticated access. Home screen displays user info. Settings screen allows logout with confirmation. Session persistence works across app restarts.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete OTP-based authentication flow with protected routes and session persistence</what-built>
  <how-to-verify>
Test the complete authentication flow:

1. **Sign-Up Flow:**
   - Launch app (should show sign-in screen if not authenticated)
   - Enter your email address
   - Tap "Send Login Code"
   - Check your email inbox for OTP code from Supabase
   - Enter the 6-digit code on verification screen
   - Verify successful redirect to home screen showing your email

2. **Session Persistence:**
   - Close the app completely (swipe away from app switcher)
   - Reopen the app
   - Verify you're still signed in and see the home screen (no need to re-authenticate)

3. **Protected Routes:**
   - While signed in, note the current URL
   - Sign out from Settings
   - Try to manually navigate to /(auth)/index
   - Verify automatic redirect to /sign-in (protected route guard working)

4. **Logout Flow:**
   - Sign in again
   - Navigate to Settings
   - Tap "Log Out"
   - Confirm the logout dialog
   - Verify redirect to sign-in screen
   - Try to navigate back - verify you cannot access protected screens

5. **Cross-Platform (if possible):**
   - Test on both iOS simulator and Android emulator
   - Verify auth flow works on both platforms
   - Verify session persistence works on both platforms

**Expected Behavior:**
- OTP emails arrive within 30 seconds
- Code verification is instant (<2s)
- No visual flicker during session checks
- Protected routes always guard correctly
- Session survives app restarts

**Common Issues to Check:**
- If OTP email doesn't arrive: Check Supabase logs, spam folder, or try resending
- If session doesn't persist: Check AsyncStorage permissions, Supabase autoRefreshToken config
- If protected routes don't guard: Check SessionProvider is wrapping root layout
- If app crashes on auth: Check all environment variables are set correctly
  </how-to-verify>
  <resume-signal>
Type "approved" if all tests pass, or describe any issues encountered.
  </resume-signal>
</task>

</tasks>

<verification>
1. Complete authentication flow works end-to-end (sign in → verify OTP → home)
2. Session persists across app restarts without re-authentication
3. Protected routes redirect unauthenticated users to sign-in
4. Logout clears session and redirects to sign-in
5. No TypeScript errors in any auth-related files
6. All screens render without crashes on both iOS and Android
7. Email validation prevents invalid inputs
8. Loading states prevent double-submission
</verification>

<success_criteria>
- Users can sign up and log in using email OTP authentication
- Sessions persist across app restarts via AsyncStorage
- Protected routes successfully guard against unauthenticated access
- Users can log out from Settings and session is cleared
- All Phase 1 success criteria are met:
  1. User can sign up with email magic link and receive the link in their inbox ✓ (using OTP)
  2. User can log in via magic link and session persists across app restarts ✓
  3. User can log out from Settings and session is cleared ✓
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-auth/01-03-SUMMARY.md` documenting:
- Authentication UI implementation (sign-in, OTP verification)
- Protected route guard pattern
- Session persistence behavior observed
- Any UX improvements noted during testing
- Supabase email deliverability observations (blocker flagged in STATE.md)
- Next phase: Phase 2 (Onboarding + Preferences)
</output>
