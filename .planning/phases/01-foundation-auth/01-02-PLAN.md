---
phase: 01-foundation-auth
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - components/auth/SessionProvider.tsx
  - lib/hooks/useStorageState.ts
  - app/_layout.tsx
autonomous: true

must_haves:
  truths:
    - "App checks for existing session on launch"
    - "Session state is available throughout the app via useSession hook"
    - "Session persists when app is closed and reopened"
    - "Auth state changes trigger re-renders in consuming components"
  artifacts:
    - path: "components/auth/SessionProvider.tsx"
      provides: "React Context for session management"
      exports: ["SessionProvider", "useSession"]
      min_lines: 60
    - path: "lib/hooks/useStorageState.ts"
      provides: "Session persistence hook with SecureStore"
      exports: ["useStorageState", "setStorageItemAsync"]
      min_lines: 40
    - path: "app/_layout.tsx"
      provides: "Root layout with SessionProvider wrapper"
      contains: "SessionProvider"
  key_links:
    - from: "components/auth/SessionProvider.tsx"
      to: "lib/supabase.ts"
      via: "supabase.auth.getSession() and onAuthStateChange()"
      pattern: "supabase\\.auth"
    - from: "app/_layout.tsx"
      to: "components/auth/SessionProvider.tsx"
      via: "SessionProvider wrapper around app content"
      pattern: "<SessionProvider>"
    - from: "components/auth/SessionProvider.tsx"
      to: "@supabase/supabase-js"
      via: "Session type import"
      pattern: "import.*Session.*from '@supabase/supabase-js'"
---

<objective>
Implement session management infrastructure with persistent authentication state.

Purpose: Create the core authentication state management system that tracks user sessions, persists tokens securely across app restarts, and provides session state to all screens via React Context. This enables protected route guards and authentication UI to function correctly.

Output:
- SessionProvider React Context with session state and auth methods
- useStorageState hook for secure token persistence
- Root layout configured with SessionProvider wrapper
</objective>

<execution_context>
@/Users/vincecain/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vincecain/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-auth/01-RESEARCH.md
@.planning/phases/01-foundation-auth/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Implement session persistence hook</name>
  <files>
    lib/hooks/useStorageState.ts
  </files>
  <action>
Create useStorageState hook for secure token persistence using expo-secure-store on native and localStorage on web.

Implementation based on official Expo Router authentication pattern:

```typescript
// lib/hooks/useStorageState.ts
import * as SecureStore from 'expo-secure-store';
import { useCallback, useEffect, useReducer } from 'react';
import { Platform } from 'react-native';

type UseStateHook<T> = [[boolean, T | null], (value: T | null) => void];

function useAsyncState<T>(
  initialValue: [boolean, T | null] = [true, null],
): UseStateHook<T> {
  return useReducer(
    (state: [boolean, T | null], action: T | null = null): [boolean, T | null] => [false, action],
    initialValue
  ) as UseStateHook<T>;
}

export async function setStorageItemAsync(key: string, value: string | null) {
  if (Platform.OS === 'web') {
    try {
      if (value === null) {
        localStorage.removeItem(key);
      } else {
        localStorage.setItem(key, value);
      }
    } catch (e) {
      console.error('Local storage error:', e);
    }
  } else {
    if (value == null) {
      await SecureStore.deleteItemAsync(key);
    } else {
      await SecureStore.setItemAsync(key, value);
    }
  }
}

export function useStorageState(key: string): UseStateHook<string> {
  const [state, setState] = useAsyncState<string>();

  useEffect(() => {
    if (Platform.OS === 'web') {
      try {
        if (typeof localStorage !== 'undefined') {
          setState(localStorage.getItem(key));
        }
      } catch (e) {
        console.error('Local storage error:', e);
      }
    } else {
      SecureStore.getItemAsync(key).then(value => {
        setState(value);
      });
    }
  }, [key]);

  const setValue = useCallback(
    (value: string | null) => {
      setState(value);
      setStorageItemAsync(key, value);
    },
    [key]
  );

  return [state, setValue];
}
```

IMPORTANT:
- Use SecureStore on native (iOS Keychain/Android Keystore)
- Use localStorage on web for compatibility
- Don't use requireAuthentication option (can lock users out if biometrics change)
- Export both useStorageState and setStorageItemAsync for reuse
  </action>
  <verify>
Add temporary test in app/_layout.tsx:
```typescript
import { useStorageState } from '@/lib/hooks/useStorageState';

// Inside component:
const [[isLoading, testValue], setTestValue] = useStorageState('test-key');
useEffect(() => {
  if (!isLoading) {
    console.log('Storage test:', testValue);
    setTestValue('test-value');
  }
}, [isLoading]);
```
Verify console logs "Storage test: null" then "Storage test: test-value" on subsequent launches.
  </verify>
  <done>
useStorageState hook successfully stores and retrieves values from SecureStore on native platforms and localStorage on web. Values persist across app restarts.
  </done>
</task>

<task type="auto">
  <name>Create SessionProvider with Supabase auth integration</name>
  <files>
    components/auth/SessionProvider.tsx
  </files>
  <action>
Create SessionProvider React Context that manages authentication state using Supabase Auth.

Implementation:

```typescript
// components/auth/SessionProvider.tsx
import { createContext, useContext, useEffect, useState, type PropsWithChildren } from 'react';
import { supabase } from '@/lib/supabase';
import { Session } from '@supabase/supabase-js';

type SessionContextType = {
  session: Session | null;
  isLoading: boolean;
  signIn: (email: string) => Promise<void>;
  verifyOtp: (email: string, token: string) => Promise<void>;
  signOut: () => Promise<void>;
};

const SessionContext = createContext<SessionContextType | null>(null);

export function SessionProvider({ children }: PropsWithChildren) {
  const [session, setSession] = useState<Session | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    // Get initial session on mount
    supabase.auth.getSession().then(({ data: { session } }) => {
      setSession(session);
      setIsLoading(false);
    });

    // Listen for auth state changes (sign in, sign out, token refresh)
    const { data: { subscription } } = supabase.auth.onAuthStateChange((_event, session) => {
      setSession(session);
    });

    return () => subscription.unsubscribe();
  }, []);

  const signIn = async (email: string) => {
    const { error } = await supabase.auth.signInWithOtp({
      email,
      options: {
        // Email templates can be customized in Supabase dashboard later
        emailRedirectTo: undefined, // No redirect needed for OTP
      },
    });
    if (error) throw error;
  };

  const verifyOtp = async (email: string, token: string) => {
    const { error } = await supabase.auth.verifyOtp({
      email,
      token,
      type: 'email',
    });
    if (error) throw error;
    // Session automatically established after successful verification
  };

  const signOut = async () => {
    const { error } = await supabase.auth.signOut();
    if (error) throw error;
  };

  return (
    <SessionContext.Provider value={{ session, isLoading, signIn, verifyOtp, signOut }}>
      {children}
    </SessionContext.Provider>
  );
}

export function useSession() {
  const context = useContext(SessionContext);
  if (!context) {
    throw new Error('useSession must be used within SessionProvider');
  }
  return context;
}
```

IMPORTANT:
- Use signInWithOtp (not deprecated signIn method)
- Session automatically updates via onAuthStateChange after OTP verification
- Don't manually call setSession - let Supabase auth state changes handle it
- Throw error if useSession called outside provider (catches misuse early)
  </action>
  <verify>
1. Import SessionProvider and useSession in a test component
2. Verify TypeScript compilation succeeds with correct types
3. Verify context provides session, isLoading, signIn, verifyOtp, signOut
4. Check that isLoading starts true, then becomes false after session check
  </verify>
  <done>
SessionProvider successfully manages authentication state. useSession hook provides session, loading state, and auth methods to consuming components. Auth state changes trigger re-renders correctly.
  </done>
</task>

<task type="auto">
  <name>Integrate SessionProvider into root layout</name>
  <files>
    app/_layout.tsx
  </files>
  <action>
Update root layout to wrap app content with SessionProvider, enabling session access throughout the app.

Update app/_layout.tsx:

```typescript
import "../global.css";
import { Slot } from 'expo-router';
import { SessionProvider } from '@/components/auth/SessionProvider';

export default function RootLayout() {
  return (
    <SessionProvider>
      <Slot />
    </SessionProvider>
  );
}
```

IMPORTANT:
- Keep global.css import at the top for NativeWind
- SessionProvider must wrap Slot to provide context to all routes
- Don't add any loading states here - that's handled in protected route layouts
  </action>
  <verify>
1. Run `npx expo start --clear`
2. Verify app launches without errors
3. Check console for "Supabase session check" or similar logs
4. Verify no context-related errors in console
5. Test that useSession() can be called from any screen (add temporary test in a dummy component)
  </verify>
  <done>
Root layout successfully provides SessionProvider to entire app. Session state is accessible from all screens via useSession hook. No initialization errors occur.
  </done>
</task>

</tasks>

<verification>
1. Run `npm run type-check` - no TypeScript errors
2. Run `npx expo start --clear` - app launches successfully
3. Add temporary test component that calls useSession() - no errors
4. Verify isLoading transitions from true to false
5. Verify session is null initially (no logged-in user yet)
6. Check that all exports are typed correctly (Session, SessionProvider, useSession)
</verification>

<success_criteria>
- SessionProvider wraps root layout and provides context throughout app
- useSession hook is accessible from any component
- Session state initializes on app launch via getSession()
- onAuthStateChange listener updates session on auth events
- isLoading flag prevents premature route guards
- signIn, verifyOtp, and signOut methods are implemented and typed
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-auth/01-02-SUMMARY.md` documenting:
- SessionProvider implementation details
- Session persistence approach (AsyncStorage via Supabase, SecureStore via useStorageState if needed)
- Auth method signatures and usage
- How onAuthStateChange works
- Next steps for Plan 03 (authentication UI)
</output>
